class Game
	values
		
	types
	
	instance variables
		private turn : Utilities`Color := <blue>;
		private board : map Utilities`Pos to Utilities`Color := { |-> };
		private tiles : seq of Tile := [];
		
		--inv {0,...,Utilities`boardSize-1} in set dom board;
		inv forall p in set dom board & p.x in set {0,...,Utilities`boardSize-1} and p.y in set {0,...,Utilities`boardSize-1};
		inv card (rng board) = 1;
		
	operations
        --Initialization
        public Game: () ==> Game
	        Game() == (
	            for all x in set {0, ..., Utilities`boardSize-1} do
	                for all y in set {0, ..., Utilities`boardSize-1} do
	                    board := board munion {
	                        mk_Utilities`Pos(x, y) |-> <empty>
	                    };
	                    
	            initializeTiles()
	            
	        );
        
        public initializeTiles: () ==> ()
        	initializeTiles() ==
        	(        		
        		dcl shape:seq of Utilities`Pos := [];
        		dcl corners:seq of Utilities`Pos := [];
        		dcl t:Tile;
        		
        		--figura 3
        		shape := [mk_Utilities`Pos(1,0), mk_Utilities`Pos(1,1), mk_Utilities`Pos(0,1)];
        		corners := [mk_Utilities`Pos(1,0), mk_Utilities`Pos(1,1), mk_Utilities`Pos(0,1)];
        		t := new Tile(shape,corners); 
        		tiles := tiles ^ [t];
        		
        		--figura 6
        		shape := [mk_Utilities`Pos(0,1), mk_Utilities`Pos(0,1), mk_Utilities`Pos(0,2), mk_Utilities`Pos(1,1)];
        		corners :=  [mk_Utilities`Pos(0,1), mk_Utilities`Pos(0,2), mk_Utilities`Pos(1,1)];
        		t := new Tile(shape,corners); 
        		tiles := tiles ^ [t];
        		
        		--figura 16
        		shape := [mk_Utilities`Pos(0,0), mk_Utilities`Pos(0,1), mk_Utilities`Pos(0,2), mk_Utilities`Pos(1,0), mk_Utilities`Pos(1,1)];
        		corners := [mk_Utilities`Pos(0,0), mk_Utilities`Pos(0,2), mk_Utilities`Pos(1,0), mk_Utilities`Pos(1,1)];
        		t := new Tile(shape,corners); 
        		tiles := tiles ^ [t];
        		
        	);
        
        --validate position
        public ValidPosition: Tile * Utilities`Color * Utilities`Pos ==> bool
	        ValidPosition(t, c, d) == (
	        	dcl shape : seq of Utilities`Pos := t.getShape();
	        	dcl finalPlace:Tile;
	        	dcl shape:seq of Utilities`Pos := [];
    			dcl corners:seq of Utilities`Pos := [];
	        	--verificar se apartir daquela posição o tabuleiro está vazio e é válido para aquela cor
	        	
	        	for all p in set elems shape do (
	        		
	        		if board(p) <> <empty> then
	        			return false;
	        	);
	            return true
	        );
        
        public placeTile: Tile * Utilities`Color * Utilities`Pos ==> bool
	    	placeTile(t, c, p) == (
	    	
	    		return true;
	    	)
	    	pre ValidPosition(t, c, p);
        
        public getCurrentPlayer: () ==> Utilities`Color
    		getCurrentPlayer() == return turn;
        	
		public changeTurn: () ==> ()
	        changeTurn() == (
	        
	            if turn = <blue>
	                then turn := <yellow>
	            else
	                turn := <blue>
	        )
	        post turn <> turn~;
        
        public getBoard: () ==> map Utilities`Pos to Utilities`Color
        	getBoard() == (
        		return self.board
        	);
        	
    	public getTurn: () ==> Utilities`Color
        	getTurn() == (
        		return self.turn
        	);
        
        
	functions
-- TODO Define functiones here

	traces
-- TODO Define Combinatorial Test Traces here
end Game